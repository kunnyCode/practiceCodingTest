let dd = "dfsffds";
let dddd = [1, 2, 3];
let ddd = dd.split("/");

console.log(ddd);
console.log(Array.isArray(dddd));
console.log(Array.isArray(undefined));
console.log(typeof dd);

// [1]Props drilling은 자식 컴포넌트로 props(데이터)를 전달해주는 과정에서  너무 많은 단계의 자식 컴포넌트가 있을시 일일이 하나하나 주입을 시켜줘야 하는 반복작업을 하게 되는 문제가 생깁니다. 이는 개발 과정에서 비효율을(반복작업 ,코드 가독성 문제, 유지보수 어려움 등) 초래하고 코드 차원에선 예를 들어 중간 컴포넌트는 해당 props 값이 필요하지 않음에도 불구하고 데이터를 주입받게 되고 이 때문에 불필요한 렌더링이 발생하게 됩니다.

// [2]Context API나  그 외 상태관리 라이브러리(Redux, Recoil, Mobx 등) 를 사용해 해결하는 방법이 있습니다.
// 원리는 이전처럼 props를 하위 컴포넌트에 차례로 넘겨주는 방법이 아닌 전역에 데이터를 저장하고 데이터가 필요한 컴포넌트에만 주입하는 원리입니다.
// 이는 Props drilling의 많은 단점을 보안해줍니다(반복작업 ,코드 가독성 문제, 유지보수 어려움 등)
// 하지만 다른 상태관리 프로그램을 사용할 시 또 새로운 것을 학습해야 한다는 단점이 있고, 컴포넌트의 깊이가 깊지 않은데 무턱대고 라이브러리를 도입하는 것은 오히려 코드가 더 복잡해질 수 있습니다. Context API를 사용하는 방법도 좋으나 Provider 하위로 useContext한 부분을 다 리렌더링이 되기 때문에 부분적인 상태관리가 어려울 수 있어 Props drilling과 혼용해서 사용하는 것이 좋습니다.
// 또한 컴포넌트 구조자체를 애초에 깊숙이 짜지 않는 방법도 있습니다.

// 그래서 큰 웹서비스인 경우 우선 컴포넌트 구조를 너무 깊이 짜지 않으면서 Recoil 라이브러리를 사용하는 쪽으로 해당 문제를 해결할 것 같습니다.

// [3]Recoil은 저에게 친숙한 상태관리 라이브러리기도 하지만 Redux 대비 배워야할게 많지 않고 사용이 쉬워 정하게 됐습니다.
// 또한 비동기처리나 캐싱도 Recoil내 selector기능을 활용해 처리할 수 있어 개발을 편하게 할 수 있기 때문입니다.
